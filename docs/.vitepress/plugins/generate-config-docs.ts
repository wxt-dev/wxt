import { relative, resolve } from 'node:path';
import { Project, ts, Type, Node, JSDocableNode } from 'ts-morph';
import { readFileSync, writeFileSync } from 'node:fs';
import { format } from 'prettier';
import consola from 'consola';

let hasGenerated = false;

const externalTypesPath = resolve('src/core/types/external.ts');
const configTemplatePath = resolve('docs/api/config.tpl.md');
const configPath = resolve('docs/api/config.md');

const PREFACE = `<!--
DO NOT EDIT
Generated by \`wxt/docs/.vitepress/plugins/generate-config-docs.ts\`
To make changes to the config reference, update the JSDoc in \`src/core/types/external.ts\`.
-->`;

/**
 * Custom property paths that should not be recursively inspected. Usually 3rd party types.
 */
const LEAF_PATHS = ['imports', 'vite', 'server'];

/**
 * Override any types that resolve to `import(...)` instead of their type names when calling
 * `type.getText()`.
 *
 * This also stops any further type inspection for objects, meaning the object will be documented,
 * not it's properties.
 */
const CUSTOM_TYPES = {
  manifest:
    'Manifest | Promise<Manifest> | () => Manifest | () => Promise<Manifest>',
  imports: "false | Partial<import('unimport').UnimportOptions>",
  vite: "Omit<import('vite').UserConfig, 'root' | 'configFile' | 'mode'>",
};

export function generateConfigDocs() {
  writeFileSync(configPath, '');

  const generateDocs = async () => {
    consola.info(`Generating ${relative(process.cwd(), configPath)}`);
    try {
      const project = new Project({
        tsConfigFilePath: resolve('tsconfig.json'),
      });

      // Load file containing "UserConfig"
      const externalTypesFile = project.addSourceFileAtPath(externalTypesPath);
      project.resolveSourceFileDependencies();

      const inlineConfigInterface =
        externalTypesFile.getInterfaceOrThrow('InlineConfig');

      const getDocsFor = (path: string[], node: Node<ts.Node>): string[] => {
        const pathStr = path.join('.');

        let type: Type<ts.Type>;
        if (node.isKind(ts.SyntaxKind.InterfaceDeclaration)) {
          type = node.getType();
        } else if (node.isKind(ts.SyntaxKind.PropertySignature)) {
          type = node.getTypeNodeOrThrow()?.getType();
        } else if (node.isKind(ts.SyntaxKind.MethodSignature)) {
          type = node.getType();
        } else {
          throw Error('Unsupported type node: ' + node.getKindName());
        }

        if (type.isObject() && !type.isArray() && !CUSTOM_TYPES[pathStr]) {
          return type.getProperties().flatMap((property) => {
            const childPath = [...path, property.getName()];

            return getDocsFor(childPath, property.getDeclarations()[0]);
          });
        }

        if ('getJsDocs' in node) {
          const lines: string[] = [];
          const docs = (node as unknown as JSDocableNode).getJsDocs();
          let typeText: string;
          if (CUSTOM_TYPES[pathStr]) {
            typeText = CUSTOM_TYPES[pathStr];
          } else if (type.isUnion() && !type.isBoolean()) {
            typeText = type
              .getUnionTypes()
              .map((type) => type.getText())
              .join(' | ');
          } else {
            typeText = type.getText();
          }
          const defaultValue = docs
            .flatMap((doc) => doc.getTags())
            .find((tag) => tag.getTagName() === 'default')
            ?.getCommentText();
          lines.push(
            '',
            `## ${pathStr}`,
            '',
            `- **Type**: \`${typeText}\``,
            `- **Default**: \`${defaultValue}\``,
            ...docs.flatMap((doc) => doc.getDescription()),
          );
          return lines;
        }

        return [];
      };

      const lines = getDocsFor([], inlineConfigInterface);
      const text = await format(
        PREFACE +
          '\n\n' +
          readFileSync(configTemplatePath, 'utf-8').replace(
            '{{ DOCS }}',
            lines.join('\n'),
          ),
        { parser: 'markdown' },
      );

      writeFileSync(configPath, text);
      consola.success(`Generated ${relative(process.cwd(), configPath)}`);
    } catch (err) {
      consola.fail(`Failed to generate ${relative(process.cwd(), configPath)}`);
      consola.error(err.message);
    }
  };

  return {
    name: 'docs:generate-config-docs',
    async config() {
      if (!hasGenerated) {
        hasGenerated = true;
        await generateDocs();
      }
    },
    configureServer(server: any) {
      server.watcher.add(externalTypesPath);
    },
    async handleHotUpdate(ctx: { file: string }) {
      if ([externalTypesPath, configTemplatePath].includes(ctx.file)) {
        await generateDocs();
      }
    },
  };
}
